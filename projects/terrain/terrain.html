<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
		<title>Terrain!</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="topnav">
        <a href="../../index.html">Home</a>
        <a class="active" href="../projects.html">Projects</a>
        <a href="https://www.linkedin.com/in/patrick-ribas/">LinkedIn</a>
        <a href="../../Patrick_Ribas_Resume.pdf">Resume</a>
        <a href="../../contact.html">Contact</a>
    </div>
    <div class="title">
        Randomly Generating Terrain
    </div>
    <div class="main">
        The goal of this project is to infinitely generate a landscape. 
        <br>
        Hold W to go forward!
        <br>
    </div>
    <div class="three">
    <script src="js/three.js"></script>
		<script type="module">
            
            // fbm setup
            var exponent_array = [];
            var frequency = 1.0;
            var MAX_OCTAVES = 8;
            var lacunarity = 2;
            var H = 0.9;
            for ( var i = 0; i < MAX_OCTAVES; i++ ) {
                exponent_array.push( Math.pow(frequency, -H) );
                frequency *= lacunarity;
            }

            // setup 
            var scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x87CEEB );
            //scene.fog = new THREE.Fog( 0x050505, 10, 25 );
            var screen_x = window.innerWidth - 25;
            var screen_y = window.innerHeight - 300;
            var camera = new THREE.PerspectiveCamera( 75,screen_x/screen_y, 0.1, 1000 );
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( screen_x, screen_y, false );
            document.body.appendChild( renderer.domElement );
            var mesh_material = new THREE.MeshPhongMaterial({color: 0x00ff00, vertexColors: false, wireframe:false, flatShading: true});

            const light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( 0, 3, 0 );
            scene.add( light );
            // main
            var positions = [];
            var colors = [];
            var i = 0;
            var color = new THREE.Color();
            var WIDTH = 30;
            for ( i = 0; i < 30; i += 1 )
            {
                var row = []
                for ( var j = -WIDTH; j <= WIDTH; j++ )
                {
                    var y = 0;
                    color.setRGB( 0, y, 0 );
                    row.push([ new THREE.Vector3(-i, y - 1,  j), color ]);
                }
                positions.push(row)
            }
            var vecPos = []
            for ( var k = 0; k < positions.length - 1; k += 1 ) 
            {
                var row1 = positions[k];
                var row2 = positions[k + 1];
                for ( var l = 0; l < row1.length - 1; l += 1) 
                {
                    
                    vecPos.push( row2[l][0] );
                    vecPos.push( row1[l + 1][0] );
                    vecPos.push( row1[l][0] );
                    
                    vecPos.push( row2[l][0] );
                    vecPos.push( row2[l + 1][0] );
                    vecPos.push( row1[l + 1][0] );
                    
                }

            }
            

            light.position.set( camera.position.x, camera.position.y + 1, camera.position.z );
            var geo = new THREE.BufferGeometry().setFromPoints( vecPos );
            const mesh = new THREE.Mesh( geo, mesh_material );

            scene.add( mesh );



            camera.position.x = 0;
            camera.position.y = 2;
            camera.position.z = 0;
            camera.rotation.y += Math.PI / 2


            // functions
            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize(){
                screen_x = window.innerWidth - 25;
                screen_y = window.innerHeight - 300;

                camera.aspect = screen_x / screen_y;
                camera.updateProjectionMatrix();

                renderer.setSize( screen_x, screen_y );

            }

            function fBm( point, octaves, basis ) {
                var value = 0;
                for ( var i = 0; i < octaves; i++ ) {
                    value += basis( point ) * exponent_array[i];
                    point[0] *= lacunarity;
                    point[1] *= lacunarity;
                    point[2] *= lacunarity;
                }
                if ( octaves - Math.floor(octaves) > 0){
                    value += (octaves - Math.floor(octaves)) * basis(point) * exponent_array[i];
                }
                return value;
            }

            function whiteNoise( point ) {
                return Math.random();
            }

            document.addEventListener("keydown", onDocumentKeyDown, false);
            function onDocumentKeyDown(event) {
                var keyCode = event.which;
                // these assign variables to their ascii tables
                // is just for description
                var W = 87;
                var A = 65;
                var S = 83;
                var D = 68;
                var Q = 81;
                var E = 69;
                var space = 32;
                var shift = 16;
                if ( keyCode == W )
                {
                    scene.remove(mesh);
                    var row = [];
                    for ( var j = -WIDTH; j <= WIDTH; j++ )
                    {
                        var y = fBm([-i, 0, j], MAX_OCTAVES, whiteNoise);
                        color.setRGB( 0, y, 0 );
                        row.push([ new THREE.Vector3(-i, y - 1,  j), color ]);

                    }
                    positions.push(row);
                    i += 1;
                    camera.position.x -= 1
                    var vecPos = []
                    for ( var k = 0; k < positions.length - 1; k += 1 ) 
                    {
                        var row1 = positions[k];
                        var row2 = positions[k + 1];
                        for ( var l = 0; l < row1.length - 1; l += 1) 
                        {
                            
                            vecPos.push( row2[l][0] );
                            vecPos.push( row1[l + 1][0] );
                            vecPos.push( row1[l][0] );
                            
                            vecPos.push( row2[l][0] );
                            vecPos.push( row2[l + 1][0] );
                            vecPos.push( row1[l + 1][0] );
                            
                        }

                    }
                    

                    light.position.set( camera.position.x, camera.position.y + 1, camera.position.z );
                    var geo = new THREE.BufferGeometry().setFromPoints( vecPos );

                    var mesh = new THREE.Mesh( geo, mesh_material );

                    scene.add( mesh );

                }
                else if  ( keyCode == S )
                {
                    camera.position.x += 1
                    light.position.set( camera.position.x, camera.position.y + 1, camera.position.z );

                }
                
                else if  ( keyCode == A )
                {
                    camera.position.z += 1
                    light.position.set( camera.position.x, camera.position.y + 1, camera.position.z );

                }
                else if  ( keyCode == D )
                {
                    camera.position.z -= 1
                    light.position.set( camera.position.x, camera.position.y + 1, camera.position.z );

                }
                else if ( keyCode == Q )
                {
                    camera.rotation.y += Math.PI / 8
                }
                else if ( keyCode == E )
                {
                    camera.rotation.y -= Math.PI / 8
                }
                else if  ( keyCode == space )
                {
                    camera.position.y += 1
                    light.position.set( camera.position.x, camera.position.y + 1, camera.position.z );

                }
                else if  ( keyCode == shift )
                {
                    camera.position.y -= 1
                    light.position.set( camera.position.x, camera.position.y + 1, camera.position.z );

                }
            }
            function animate() { // called every frame
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
            }
            animate();

        </script>
    </div>
</body>
</html>
