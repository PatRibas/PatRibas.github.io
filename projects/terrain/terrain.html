<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
		<title>Terrain!</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="topnav">
        <a href="../../index.html">Home</a>
        <a class="active" href="../projects.html">Projects</a>
        <a href="https://www.linkedin.com/in/patrick-ribas/">LinkedIn</a>
        <a href="../../Patrick_Ribas_Resume.pdf">Resume</a>
        <a href="../../contact.html">Contact</a>
    </div>
    <div class="title">
        Randomly Generating Terrain
    </div>
    <div class="main">
        The goal of this project is to infinitely generate a landscape.
        <br>
    </div>
    <div class="three">
    <script src="js/three.js"></script>
		<script type="module">
            
            // setup 
            var scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x87CEEB );
            //scene.fog = new THREE.Fog( 0x050505, 10, 25 );
            var screen_x = window.innerWidth - 25;
            var screen_y = window.innerHeight - 300;
            var camera = new THREE.PerspectiveCamera( 75,screen_x/screen_y, 0.1, 1000 );
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( screen_x, screen_y, false );
            document.body.appendChild( renderer.domElement );


            // main
            var dotGeometry = new THREE.BufferGeometry();

            var positions = []
            var colors = []

            var color = new THREE.Color();
            var i = 0;
            for ( i = 0; i < 10; i++ )
            {
                for ( var j = -5; j <= 5; j++ )
                {
                    positions.push( -i, 0, j );
                    color.setRGB( i * Math.random(), 0, j * Math.random() );
                    colors.push( color.r, color.g, color.b )
                }
            }

            dotGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
            dotGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

            dotGeometry.computeBoundingSphere();
            var material = new THREE.PointsMaterial( { size: 0.1, vertexColors: true } );

            var points = new THREE.Points( dotGeometry, material );
            scene.add( points );


            camera.position.x = 0;
            camera.position.y = 2;
            camera.position.z = 0;
            camera.rotation.y += Math.PI / 2



            // functions
            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize(){
                screen_x = window.innerWidth - 25;
                screen_y = window.innerHeight - 300;

                camera.aspect = screen_x / screen_y;
                camera.updateProjectionMatrix();

                renderer.setSize( screen_x, screen_y );

            }

            document.addEventListener("keydown", onDocumentKeyDown, false);
            function onDocumentKeyDown(event) {
                var keyCode = event.which;
                // these assign variables to their ascii tables
                // is just for description
                var W = 87;
                var A = 65;
                var S = 83;
                var D = 68;
                var Q = 81;
                var E = 69;
                var space = 32;
                var shift = 16;
                if ( keyCode == W )
                {
                    var new_pos = [];
                    var new_col = [];
                    for ( var j = -5; j <= 5; j++ )
                    {
                        positions.push( -i, 0, j );
                        color.setRGB( i * Math.random(), 0, j * Math.random() );
                        colors.push( color.r, color.g, color.b )
                    }
                    i += 1;
                    var new_geo = new THREE.BufferGeometry();
                    new_geo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
                    new_geo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
                    new_geo.computeBoundingSphere();
                    var p = new THREE.Points( new_geo, material );
                    scene.add( p );
                    camera.position.x -= 1

                }
                else if  ( keyCode == S )
                {
                    camera.position.x += 1
                }
                
                else if  ( keyCode == A )
                {
                    camera.position.z += 1
                }
                else if  ( keyCode == D )
                {
                    camera.position.z -= 1
                }
                else if ( keyCode == Q )
                {
                    camera.rotation.y += Math.PI / 8
                }
                else if ( keyCode == E )
                {
                    camera.rotation.y -= Math.PI / 8
                }
                else if  ( keyCode == space )
                {
                    camera.position.y += 1
                }
                else if  ( keyCode == shift )
                {
                    camera.position.y -= 1
                }
            }
            function animate() { // called every frame
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
            }
            animate();

        </script>
    </div>
    <div class="main">
        This text should be below the rendering!
    </div>
</body>
</html>
